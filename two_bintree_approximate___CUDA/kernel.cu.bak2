#include <stdio.h>
#include <stdlib.h>
#include <time.h>
//#include <unistd.h>
#include <string.h>
#include <math.h>
#include <stdbool.h>
#define COUNT 20

#define DATASET_NUM 9
#define MAX_INT_DEF 0xfffffff
#define max_clock_stamp 10240
#define max_clock_store 8
#define DIM 3
clock_t run_time_debug[max_clock_store];
int clock_index=0;
typedef struct point{
    float values[DIM];
    float th;//store distance or quantity
}point;

typedef struct node{
    point data;
    struct node* left;
    struct node* right;
}node;
int mypow(int x,int y){
    int result=1;
    for (int i = 0; i <y ; ++i) {
        result*=x;
    }
    return result;
}
void print_nD_arr(point* arr){
    int size=(int)roundf(arr[0].th);//roundf: in order to make sure floating error does not affect size number!
    printf("index");
    for (int k = 0; k <DIM ; ++k) printf("\t\tdata[%d]\t",k);
    printf("\t\tth/dist\n");

    for (int i = 0; i <=size ; ++i) {
        printf("%d\t\t",i);
        for (int j = 0; j <DIM ; ++j) {
            printf("%f\t\t",arr[i].values[j]);
        }
        printf("%d\n",(int)arr[i].th);
    }
}
void print_this_point_woth(point thispoint){
    printf("(");
    for (int i = 0; i <DIM ; ++i) printf("%.1f, ",thispoint.values[i]);
    printf("\b\b)");
}
void print_this_point(point thispoint){
    printf("(");
    for (int i = 0; i <DIM ; ++i) printf("%.1f, ",thispoint.values[i]);
    printf("\b\b)_");
    printf("%.1f",thispoint.th);
    printf("\n");
}
void swap(point *x,point *y){
    point tmp;
    tmp=*x;
    *x=*y;
    *y=tmp;
}
point *super_gen_seq_arr(int number,bool reversed){
    int i,dim,j;
    point *arr=(point*)malloc(sizeof(point)*(number+1));
    for (i = 1; i <=number ; i++) {
        j=i;
        if(reversed==true) {
            j=number-i+1;
        }
        for (dim = 0; dim <DIM ; dim++) {
            arr[i].values[dim]=(float)(dim*100+j);//init
        }
        arr[i].th=MAX_INT_DEF;//init
    }
    arr[0].th=number;
    return arr;
}
point *super_gen_rand_arr(int number,int max){
    srand(time(NULL));
    int i,dim;
    point *arr=(point*)malloc(sizeof(point)*(number+1));
    for (i = 1; i <=number ; i++) {
        for (dim = 0; dim <DIM ; dim++) {
            arr[i].values[dim]=(float)(rand() % (max+1));//should use this

//            arr[i].values[dim]=((float)(rand()%100));//init
        }
        arr[i].th=MAX_INT_DEF;//init
    }
    arr[0].th=number;
    return arr;
}
point* deep_copy(point *arr){
    int size=(int)roundf(arr[0].th);
    point* newarr=(point*)malloc(sizeof(point)*(size+1));
    memcpy(newarr,arr, sizeof(point)*(size+1));
    return newarr;
}

int print_test_qsort(point* arr){
    int val=0;
    for (int i = 1; i <=(int)roundf(arr[0].th) ; ++i) {
        val+=mypow(10,(int)roundf(arr[0].th)-i)*(int)arr[i].values[0];
    }
    return val;
}
void quicksort(point *orgarr,int first,int last,int for_which_dim){
    int from_first,from_last,pivot;
//    int testing;
//    int test_from_first_val;
//    int test_from_last_val;
//    int test_pivot_val;
//    testing=print_test_qsort(orgarr);
    if(for_which_dim>DIM){
        printf("dim Err into quick sort\n");
        EXIT_FAILURE;
    }
    if(first<last){
        pivot=first;
        from_first=first;
        from_last=last;
        while(from_first<from_last){//if left index & right index not cross mid-> continue
            //if not normal-> move the index
            while((orgarr[from_first].values[for_which_dim]<=orgarr[pivot].values[for_which_dim])&&(from_first<last)) from_first++;
            //if not normal-> move the index
            while(orgarr[from_last].values[for_which_dim]>orgarr[pivot].values[for_which_dim]) from_last--;
            //            //if valid first and last index-> swap two chosen points (1 at right and another ar left)
            if(from_first<from_last)    swap(&orgarr[from_first],&orgarr[from_last]);
//            otherwise continue
//            printf("----\n");
//            print_nD_arr(orgarr);
//            usleep(1000000*1);
//            print_nD_arr(orgarr);
        }
        //change the pivot to the right side of the chosen point
        swap(&orgarr[pivot],&orgarr[from_last]);
        //insert node for right side of the tree
        quicksort(orgarr,first,from_last-1,for_which_dim);
        //insert node for left side of the tree
        quicksort(orgarr,from_last+1,last,for_which_dim);
    }
}
void print2DUtil(node *root, int space){
    if (root == NULL) return;
    int i;
    space += COUNT;

    print2DUtil(root->right, space);
    printf("\n");
    for (i = COUNT; i < space; i++) printf(" ");
    printf("(");
    for (i = 0; i <DIM ; i++) {
        printf("%.1f  ",root->data.values[i]);
    }
    printf(")\n");
//    printf("(%d,%d)\n", root->data.,root->data.y);
    print2DUtil(root->left, space);
}
void print_node(node* root){
    int i;

    printf("(");
    for (i = 0; i <DIM ; i++) {
        printf("%.1f ",root->data.values[i]);
    }
    printf(")th:%d\n",(int)roundf(root->data.th));
}
int print_bt(node* root){
    static int count=0;
    int i;
    if(root==NULL) return 0;
//    usleep(0.1*1000000);
    printf("(");
    for (i = 0; i <DIM ; i++) {
        printf("%.1f ",root->data.values[i]);
    }
    printf(")th:%d\n",(int)roundf(root->data.th));
    count++;
    print_bt(root->left);
    print_bt(root->right);
    return count;
}
int super_rand(int min,int max){
    srand(time(NULL));
    return rand()%(max+1-min)+min;
}
int find_mid_index(point* sorted_arr,point target,int chosen_dim){
    int i;
    for(i=1;i<=(int)sorted_arr[0].th;i++){
        if(sorted_arr[i].values[chosen_dim]>=target.values[chosen_dim]) return i-1;//previous index
    }
}
void show_time(char* str){
    run_time_debug[clock_index%max_clock_store]=clock();
    printf("%d____%d ms__ %s\n",clock_index,(int)(1000*(run_time_debug[clock_index%max_clock_store]-run_time_debug[((clock_index-1))%max_clock_store])/CLOCKS_PER_SEC),str);
    if(clock_index==max_clock_stamp) exit(10);
    clock_index++;
}
point* super_selection(point *orgarr,const char *up_down,int choose_dim,bool random_pick_med){
//    int portion=100/split_portion;// for annoy should change here! maybe: int->float//original
    // for GPU. Generate 32 kinds of portion
    printf("--------new super selection----------\n");

    int orgsorted_size=(int)roundf(orgarr[0].th);
    point *new_arr;
    int new_arr_size;
    int i;
    int mid_index;
    point mid_point;
    //orginial_arr_size is same as sorted_arr_size
//    show_time("initialize super_selection");
    point *sorted_orgarr=deep_copy(orgarr);
    quicksort(sorted_orgarr,1,orgsorted_size,choose_dim);
//    show_time("Quick sort");
//    if(orgarr[0].th<=3) random_pick_med=false;

    if (random_pick_med==true && (int)sorted_orgarr[0].th>1){
        //rand pick 2 points and calc the mean with random only pick an index with randonly pick 2 index
        int rindex1,rindex2;//index1 & index2
        point val1,val2;
        rindex1=super_rand(1,(int)sorted_orgarr[0].th);
//        show_time("find rindex1");
        do{
            rindex2=super_rand(1,(int)sorted_orgarr[0].th);
            if(rindex1==rindex2) rindex2= (rindex2+super_rand(0,(int)sorted_orgarr[0].th-2))%(int)sorted_orgarr[0].th+1;
                //org rindex2+- rand()
        }while(rindex1==rindex2);//randomed value cannot be the same//but condition variable is slow So this is just a backup plan
//        show_time("find rindex2");
        printf("index=%d,%d\n",rindex1,rindex2);
        //calc where should the index should be inserted in the array
        val1=sorted_orgarr[rindex1];
        val2=sorted_orgarr[rindex2];
        //find out the mid value
        for(i=0;i<DIM;i++) mid_point.values[i]=(val1.values[i]+val2.values[i])/2;//ignore the th value//FUTURE: can be simplify to one dim only
//        show_time("find virtual point");
        //find out the cutting index--with dim
        mid_index=find_mid_index(sorted_orgarr,mid_point,choose_dim);

        printf("using %.1f as mid_index\n",((float)mid_index+0.5));
//        show_time("find mid_index");

    }else if(!random_pick_med && (int)sorted_orgarr[0].th>1){
        mid_index = (int) ((1 + orgsorted_size) / 2);
        for(i=0;i<DIM;i++) mid_point.values[i]=((sorted_orgarr[mid_index].values[i]+sorted_orgarr[mid_index+1].values[i])/2);//deleted one or previous one
    }else if((int)sorted_orgarr[0].th<=1){
        new_arr=(point*)malloc(sizeof(point));//one point array
        new_arr[0].th=0;
        for(i=0;i<DIM;i++) new_arr[0].values[i]=sorted_orgarr[1].values[i];//deleted one or previous one
//        show_time("Edge-- End of leaf");
        return new_arr;
    }
    //for when only 1 element left
//    show_time("figure out mid_point & mid_split");
    if(strcmp(up_down,"down")==0){
//        printf("DOWN\n");
        new_arr_size=mid_index;
        new_arr=(point*)malloc(sizeof(point)*(1+new_arr_size));
        for(i=1;i<=new_arr_size;i++) new_arr[i]=sorted_orgarr[i];
        for(i=0;i<DIM;i++) new_arr[0].values[i]=mid_point.values[i];
//        show_time("down arr created!");
    }else if(strcmp(up_down,"up")==0){
//        printf("UP\n");
        new_arr_size=orgsorted_size-mid_index;// for annoy should change here!
        new_arr=(point*)malloc(sizeof(point)*(1+new_arr_size));
        for(i=1;i<=new_arr_size;i++) new_arr[i]=sorted_orgarr[mid_index+i];
        for(i=0;i<DIM;i++) new_arr[0].values[i]=mid_point.values[i];
//        show_time("up arr created!");
    }else{
        printf("Debug: arr is empty & super_selection failed!!!\n");
        exit(0);
    }

    new_arr[0].th=(float)new_arr_size;
    return new_arr;
}
node* convert_2_KDtree_code(point* arr,float th,int brute_force_range,int chosen_dim,bool random_med){
    node* new_node=(node*)malloc(sizeof(node));
    point* arr_left;//=(point*) malloc(sizeof(point)*(arr[0].th+1));
    point* arr_right;//=(point*) malloc(sizeof(point)*(arr[0].th+1));
    int i;
//    printf("\nEach recusrsion array\n");
//    print_nD_arr(arr);
    chosen_dim++;
    chosen_dim%=DIM;
    printf("Current Dim %d\n",chosen_dim);
//    printf("updown st\n");
    arr_left=(super_selection(arr,"down",chosen_dim,random_med));//too slow!!!!!!!!!!!fix here~~
    arr_right=(super_selection(arr,"up",chosen_dim,random_med));
//    printf("updown End\n");
    new_node->data.th=th;
    if((int)roundf(arr_left[0].th)>=brute_force_range){
        for(i=0;i<DIM;i++) new_node->data.values[i]= arr_left[0].values[i];
        printf("L\n");
        print_nD_arr(arr_left);
        print_node(new_node);
        new_node->left=convert_2_KDtree_code(arr_left,th,brute_force_range,chosen_dim,random_med);
    }else{
        for(i=0;i<DIM;i++) new_node->data.values[i]= arr_left[0].values[i];
        printf("L----NULL\n");
        print_nD_arr(arr_left);
        print_node(new_node);
        new_node->left=NULL;
    }
    if((int)roundf(arr_right[0].th)>=brute_force_range){
        for(i=0;i<DIM;i++) new_node->data.values[i]= arr_right[0].values[i];
        printf("R\n");
        print_nD_arr(arr_right);
        print_node(new_node);
        new_node->right=convert_2_KDtree_code(arr_right,th,brute_force_range,chosen_dim,random_med);
    }else{
        for(i=0;i<DIM;i++) new_node->data.values[i]= arr_right[0].values[i];
        printf("R----NULL\n");
        print_nD_arr(arr_right);
        print_node(new_node);
        new_node->right=NULL;
    }
    printf("------------------pop------------------------\n");
    return new_node;
}
node* convert_2_KDtree(point* arr, bool random_med){
    return convert_2_KDtree_code(arr,1,1,-1,random_med);
}
void push_front(point* org_arr,point desire_push,int k,bool k_full_lock){//k_full_lock: true to avoid element be popped if queue overflow!
//    printf("----------------------------------------------------\n");
    //need to update the arr[0].th as well!
    if(k_full_lock && k<=org_arr[0].th) return;
    int i;
    org_arr[0].th+=(float)(1-(int)(k<=(int)org_arr[0].th));
//    printf("%d\n",org_arr[0].th);
    for (i = (int)roundf(org_arr[0].th); i>1 ; i--) {
//        printf(" %d",i);
        org_arr[i]=org_arr[i-1];
    }
//    printf("\n");
    org_arr[1]=desire_push;
//    return org_arr;
}
void push_back(point* org_arr,point desire_push,int k, bool k_full_lock){//k_full_lock: true to avoid element be popped if queue overflow!
    if(k_full_lock && k<=(int)org_arr[0].th) return;
    int i;
    if(k<=(int)org_arr[0].th){
        for(i=1;i<(int)org_arr[0].th;i++) org_arr[i]=org_arr[i+1];
    }
    org_arr[0].th+=(float)(1-(int)(k<=(int)org_arr[0].th));
    org_arr[(int)org_arr[0].th]=desire_push;

}
void distance_calc(point target, point *on_leaf){
    double dist=0;
    int dim;
    for (dim = 0; dim <DIM ; dim++) {
        dist+= pow(target.values[dim]-on_leaf->values[dim],2);
    }
    dist=pow(dist,0.5);
    on_leaf->th=(float)dist;
//    return (float) dist;
}
void k_nearest_search_code(int k,node* root,bool approximate,point target,int chosen_dim,point* nearest_points){
    //under occasion: approximate==true && only one point
    // this recursion is for approximate kNN search where k=1
    if(nearest_points[0].th>=(float)k) return;//return when have found k's element
    if(approximate) {
        if (root == NULL) return;
        else printf("--->%.1f", root->data.values[chosen_dim]);
        bool is_leaf = (root->left == NULL) && (root->right == NULL);
        if ((nearest_points[1].values[chosen_dim] != root->data.values[chosen_dim] || nearest_points[0].th == 0) &&
            (is_leaf)) {//(value comapre|| init)&&(is leaf)
            printf("S\t");//S means store!
            distance_calc(target, &root->data);
//            push_front(nearest_points, root->data, k,true);
            push_back(nearest_points, root->data, k,true);
        }//need modified when k>1
        if (target.values[chosen_dim] < root->data.values[chosen_dim]) {
            chosen_dim++;
            chosen_dim %= DIM;
            k_nearest_search_code(k, root->left, approximate, target, chosen_dim, nearest_points);
        } else {
            chosen_dim++;
            chosen_dim %= DIM;
            k_nearest_search_code(k, root->right, approximate, target, chosen_dim, nearest_points);
        }
    }else {
        if(chosen_dim==0) printf("\n");//for printing
        if (root == NULL) return;
        else{printf("----->(");for (int i = 0; i <DIM ; ++i) {printf("%.1f ", root->data.values[i]); }printf(")");}
        bool is_leaf = (root->left == NULL) && (root->right == NULL);
        if ((nearest_points[1].values[chosen_dim] != root->data.values[chosen_dim] || nearest_points[0].th == 0) && (is_leaf)) {//(value comapre|| init)&&(is leaf)
            printf("S\t");//S means store!
            distance_calc(target, &root->data);
//            push_front(nearest_points, root->data, k,true);
            push_back(nearest_points, root->data, k,true);
        }//need modified when k>1
        if (target.values[chosen_dim] < root->data.values[chosen_dim]) {
            chosen_dim++;
            chosen_dim %= DIM;
            k_nearest_search_code(k, root->left, approximate, target, chosen_dim, nearest_points);
            if(root->right!=NULL){
                k_nearest_search_code(k, root->right, approximate, target, chosen_dim, nearest_points);
            }
        } else {
            chosen_dim++;
            chosen_dim %= DIM;
            k_nearest_search_code(k, root->right, approximate, target, chosen_dim, nearest_points);
            if(root->left!=NULL){
                k_nearest_search_code(k, root->left, approximate, target, chosen_dim, nearest_points);
            }
        }
    }
}
point* k_nearest_search(int k,node* tree,bool approximate,point target){
    point* nearest_points=(point*)malloc(sizeof(point)*(k+1));
    nearest_points[0].th=0;
    printf("value searched(S:stored): ");
    k_nearest_search_code(k,tree,approximate,target,0,nearest_points);
    printf("\n");
    return nearest_points;
}
point k_nearest_search_wo_recursion_stack_k1_approx_code(node* root,point target){//return nearest_point
    node* current=root;
    int dim_count=0;
    printf("traverse route:");
    print_this_point_woth(current->data);
    while(current->left && current->right){
        if(current->data.values[dim_count]>target.values[dim_count] && current->left){
            current=current->left;
        } else if (current->data.values[dim_count]<=target.values[dim_count] && current->right){
            current=current->right;
        }
        else{
            if(current->left) current=current->left;
            else current=current->right;
        }
        dim_count++;
        dim_count%=DIM;
        printf("--->");
        print_this_point_woth(current->data);
        if(dim_count==0) printf("\n");
    }
    distance_calc(target,&current->data);
    printf("\n");
    return current->data;
}
point* k_nearest_search_wo_recusrion_stack(int k,node* tree,bool approximate,point target){
    point* nearest_points=(point*)malloc(sizeof(point)*(k+1));
    nearest_points[0].th=(float)k;
    int i;
    point onenearest;
    if(k==1 && approximate) {
        onenearest=k_nearest_search_wo_recursion_stack_k1_approx_code(tree,target);
//        print_this_point(onenearest);
        nearest_points[1]=onenearest;
    }
    else{
        printf("Sorry not yet finish this part yet!\n");
    }
    show_time("found the nearest point(s)");
    return nearest_points;
}
int gpu_kd_portion(int parallel_num,int scaling){//scaling=1~parallel_num
    return parallel_num/scaling;
}
void write_data_to_txt(char* fname,point* arr){
    FILE *f=fopen(fname,"w");
    if(f==NULL) exit(2);
    int k,i;

    fprintf_s(f,"%d %d\n",DIM,(int)arr[0].th);
    for (i = 1; i <=(int)arr[0].th ; ++i) {
//        fprintf_s(f,"%d\t\t",i);
        for (int j = 0; j <DIM ; ++j) {
            fprintf_s(f,"%f\t\t",arr[i].values[j]);
        }
        fprintf_s(f,"%d\n",(int)arr[i].th);
    }
    fclose(f);
}
point* read_data_from_txt(char* fname){
    FILE *f;
    char *orgarr;//have to mind the dataset length!!
    f=fopen(fname,"r+");
    if(f==NULL) exit(2);
    int dim,num_data,i,j;
    fscanf(f,"%d %d\n",&dim,&num_data);//second line to read info
    printf("dim:%d\tdatanum:%d\n",dim,num_data);
//    float buffdata[num_data+1][dim];
//    int buffth[num_data];
    point *input;
    input=(point*)malloc(sizeof(point)*(num_data+1));
    for(i=1;i<=num_data;i++){
        //perline
        for(j=0;j<dim;j++) fscanf(f,"%f\t\t",&input[i].values[j]);
        fscanf(f,"%f\n",&input[i].th);
    }
    fclose(f);
    input[0].th=(float)num_data;
    return input;
}



int main(){
    clock_t main_start;
    run_time_debug[0]=main_start=clock();

    //Traverse KD tree approximately with non-recursive & non-stack just one while loop k=1

    //build tree from disk file

    node* tree;
    tree=convert_2_KDtree(read_data_from_txt("9points_rand_max39.txt"),true);
    print2DUtil(tree,0);
    show_time("tree print Fin");
    point target;
    point* nearest_points;
    target.values[0] = 32;
    target.values[1] = 11;
    target.values[2] = 65;
    show_time("create_dependency Fin");
    nearest_points=k_nearest_search_wo_recusrion_stack(1,tree,true,target);
    show_time("kNN search fin");

    printf("target: ");print_this_point(target);
    print_nD_arr(nearest_points);


    return clock()-main_start;
}